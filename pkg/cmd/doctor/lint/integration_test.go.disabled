//go:build integration

package doctor_test

import (
	"bytes"
	"context"
	"testing"

	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/cli-runtime/pkg/genericclioptions"

	"github.com/lburgazzoli/k3s-envtest/pkg/cluster"
	doctorcmd "github.com/lburgazzoli/odh-cli/pkg/cmd/doctor"
	"github.com/lburgazzoli/odh-cli/pkg/resources"
)

func TestLintCommand_Integration(t *testing.T) {
	g := NewWithT(t)
	ctx := context.Background()

	// Start k3s test cluster
	cfg := cluster.Config{
		StartupTimeout: "60s",
	}

	cl, err := cluster.NewCluster(cfg)
	g.Expect(err).ToNot(HaveOccurred())
	defer cl.Stop()

	g.Expect(cl.Start(ctx)).To(Succeed())

	// Create a test DataScienceCluster in the cluster
	dsc := &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": resources.DataScienceCluster.APIVersion(),
			"kind":       resources.DataScienceCluster.Kind,
			"metadata": map[string]interface{}{
				"name": "test-dsc",
			},
			"spec": map[string]interface{}{
				"components": map[string]interface{}{
					"dashboard": map[string]interface{}{
						"managementState": "Managed",
					},
				},
			},
			"status": map[string]interface{}{
				"release": map[string]interface{}{
					"version": "2.17.0",
				},
				"components": map[string]interface{}{
					"dashboard": map[string]interface{}{
						"phase": "Ready",
					},
				},
			},
		},
	}

	// Note: In a real integration test, we would apply the CRD first
	// For now, this demonstrates the test structure

	// Create ConfigFlags from the test cluster kubeconfig
	kubeconfig, err := cl.GetKubeConfig(ctx)
	g.Expect(err).ToNot(HaveOccurred())

	configFlags := genericclioptions.NewConfigFlags(true)
	configFlags.KubeConfig = &kubeconfig

	// Create lint options
	outBuf := &bytes.Buffer{}
	errBuf := &bytes.Buffer{}

	streams := genericclioptions.IOStreams{
		In:     &bytes.Buffer{},
		Out:    outBuf,
		ErrOut: errBuf,
	}

	sharedOpts := doctorcmd.NewSharedOptions(streams)
	sharedOpts.ConfigFlags = configFlags

	lintOpts := doctorcmd.NewLintOptions(sharedOpts)

	// Complete and validate
	g.Expect(lintOpts.Complete()).To(Succeed())
	g.Expect(lintOpts.Validate()).To(Succeed())

	// Run lint command
	err = lintOpts.Run(ctx)

	// In a minimal cluster, we might not have OpenShift AI installed
	// So we expect certain errors but the command should still run
	if err != nil {
		t.Logf("Lint command error (expected in minimal cluster): %v", err)
	}

	output := outBuf.String()
	t.Logf("Lint output:\n%s", output)

	// Verify output contains expected sections
	g.Expect(output).To(ContainSubstring("Detecting cluster version"))
	g.Expect(output).To(ContainSubstring("Discovering OpenShift AI components"))
	g.Expect(output).To(ContainSubstring("Discovering workload custom resources"))

	// Note: The output will vary based on what's actually installed
	// In a full integration test, we would:
	// 1. Apply OpenShift AI CRDs
	// 2. Create DSC and DSCI resources
	// 3. Verify specific check results

	_ = dsc // Keep dsc around for future use when we apply it to the cluster
}

func TestLintCommand_JSONOutput(t *testing.T) {
	g := NewWithT(t)
	ctx := context.Background()

	// Start k3s test cluster
	cfg := cluster.Config{
		StartupTimeout: "60s",
	}

	cl, err := cluster.NewCluster(cfg)
	g.Expect(err).ToNot(HaveOccurred())
	defer cl.Stop()

	g.Expect(cl.Start(ctx)).To(Succeed())

	kubeconfig, err := cl.GetKubeConfig(ctx)
	g.Expect(err).ToNot(HaveOccurred())

	configFlags := genericclioptions.NewConfigFlags(true)
	configFlags.KubeConfig = &kubeconfig

	outBuf := &bytes.Buffer{}
	errBuf := &bytes.Buffer{}

	streams := genericclioptions.IOStreams{
		In:     &bytes.Buffer{},
		Out:    outBuf,
		ErrOut: errBuf,
	}

	sharedOpts := doctorcmd.NewSharedOptions(streams)
	sharedOpts.ConfigFlags = configFlags
	sharedOpts.OutputFormat = doctorcmd.OutputFormatJSON

	lintOpts := doctorcmd.NewLintOptions(sharedOpts)

	g.Expect(lintOpts.Complete()).To(Succeed())
	g.Expect(lintOpts.Validate()).To(Succeed())

	// Run with JSON output
	err = lintOpts.Run(ctx)
	if err != nil {
		t.Logf("Lint command error (expected in minimal cluster): %v", err)
	}

	output := outBuf.String()
	t.Logf("JSON output:\n%s", output)

	// Verify JSON structure (even if empty)
	g.Expect(output).To(Or(
		ContainSubstring("\"components\""),
		ContainSubstring("Detecting cluster version"), // Discovery output before JSON
	))
}
